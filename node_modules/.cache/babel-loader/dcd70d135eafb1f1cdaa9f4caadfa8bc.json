{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deprecate = exports.collectionShorthand = exports.itemShorthand = exports.contentShorthand = exports.multipleProp = exports.demand = exports.givenProps = exports.some = exports.every = exports.disallow = exports.suggest = exports.domNode = exports.as = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _difference2 = _interopRequireDefault(require(\"lodash/fp/difference\"));\n\nvar _trim2 = _interopRequireDefault(require(\"lodash/fp/trim\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/fp/isObject\"));\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/fp/pick\"));\n\nvar _keys2 = _interopRequireDefault(require(\"lodash/fp/keys\"));\n\nvar _isPlainObject2 = _interopRequireDefault(require(\"lodash/fp/isPlainObject\"));\n\nvar _isFunction2 = _interopRequireDefault(require(\"lodash/fp/isFunction\"));\n\nvar _compact2 = _interopRequireDefault(require(\"lodash/fp/compact\"));\n\nvar _isNil2 = _interopRequireDefault(require(\"lodash/fp/isNil\"));\n\nvar _take2 = _interopRequireDefault(require(\"lodash/fp/take\"));\n\nvar _sortBy2 = _interopRequireDefault(require(\"lodash/fp/sortBy\"));\n\nvar _sum2 = _interopRequireDefault(require(\"lodash/fp/sum\"));\n\nvar _min2 = _interopRequireDefault(require(\"lodash/fp/min\"));\n\nvar _map2 = _interopRequireDefault(require(\"lodash/fp/map\"));\n\nvar _flow2 = _interopRequireDefault(require(\"lodash/fp/flow\"));\n\nvar _memoize2 = _interopRequireDefault(require(\"lodash/fp/memoize\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _leven = _interopRequireDefault(require(\"./leven\"));\n\nvar typeOf = function typeOf() {\n  var _Object$prototype$toS;\n\n  return (_Object$prototype$toS = Object.prototype.toString).call.apply(_Object$prototype$toS, arguments);\n};\n/**\n * Ensure a component can render as a give prop value.\n */\n\n\nvar as = function as() {\n  return _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object, _propTypes.default.string, _propTypes.default.symbol]).apply(void 0, arguments);\n};\n/**\n * Ensure a prop is a valid DOM node.\n */\n\n\nexports.as = as;\n\nvar domNode = function domNode(props, propName) {\n  // skip if prop is undefined\n  if (props[propName] === undefined) return; // skip if prop is valid\n\n  if (props[propName] instanceof Element) return;\n  throw new Error(\"Invalid prop \\\"\".concat(propName, \"\\\" supplied, expected a DOM node.\"));\n};\n/**\n * Similar to PropTypes.oneOf but shows closest matches.\n * Word order is ignored allowing `left chevron` to match `chevron left`.\n * Useful for very large lists of options (e.g. Icon name, Flag name, etc.)\n * @param {string[]} suggestions An array of allowed values.\n */\n\n\nexports.domNode = domNode;\n\nvar suggest = function suggest(suggestions) {\n  if (!Array.isArray(suggestions)) {\n    throw new Error('Invalid argument supplied to suggest, expected an instance of array.');\n  }\n  /* eslint-disable max-nested-callbacks */\n\n\n  var findBestSuggestions = (0, _memoize2.default)(function (str) {\n    var propValueWords = str.split(' ');\n    return (0, _flow2.default)((0, _map2.default)(function (suggestion) {\n      var suggestionWords = suggestion.split(' ');\n      var propValueScore = (0, _flow2.default)((0, _map2.default)(function (x) {\n        return (0, _map2.default)(function (y) {\n          return (0, _leven.default)(x, y);\n        }, suggestionWords);\n      }), (0, _map2.default)(_min2.default), _sum2.default)(propValueWords);\n      var suggestionScore = (0, _flow2.default)((0, _map2.default)(function (x) {\n        return (0, _map2.default)(function (y) {\n          return (0, _leven.default)(x, y);\n        }, propValueWords);\n      }), (0, _map2.default)(_min2.default), _sum2.default)(suggestionWords);\n      return {\n        suggestion: suggestion,\n        score: propValueScore + suggestionScore\n      };\n    }), (0, _sortBy2.default)(['score', 'suggestion']), (0, _take2.default)(3))(suggestions);\n  });\n  /* eslint-enable max-nested-callbacks */\n  // Convert the suggestions list into a hash map for O(n) lookup times. Ensure\n  // the words in each key are sorted alphabetically so that we have a consistent\n  // way of looking up a value in the map, i.e. we can sort the words in the\n  // incoming propValue and look that up without having to check all permutations.\n\n  var suggestionsLookup = suggestions.reduce(function (acc, key) {\n    acc[key.split(' ').sort().join(' ')] = true;\n    return acc;\n  }, {});\n  return function (props, propName, componentName) {\n    var propValue = props[propName]; // skip if prop is undefined or is included in the suggestions\n\n    if (!propValue || suggestionsLookup[propValue]) return; // check if the words were correct but ordered differently.\n    // Since we're matching for classNames we need to allow any word order\n    // to pass validation, e.g. `left chevron` vs `chevron left`.\n\n    var propValueSorted = propValue.split(' ').sort().join(' ');\n    if (suggestionsLookup[propValueSorted]) return; // find best suggestions\n\n    var bestMatches = findBestSuggestions(propValue); // skip if a match scored 0\n\n    if (bestMatches.some(function (x) {\n      return x.score === 0;\n    })) return;\n    return new Error([\"Invalid prop `\".concat(propName, \"` of value `\").concat(propValue, \"` supplied to `\").concat(componentName, \"`.\"), \"\\n\\nInstead of `\".concat(propValue, \"`, did you mean:\"), bestMatches.map(function (x) {\n      return \"\\n  - \".concat(x.suggestion);\n    }).join(''), '\\n'].join(''));\n  };\n};\n/**\n * Disallow other props from being defined with this prop.\n * @param {string[]} disallowedProps An array of props that cannot be used with this prop.\n */\n\n\nexports.suggest = suggest;\n\nvar disallow = function disallow(disallowedProps) {\n  return function (props, propName, componentName) {\n    if (!Array.isArray(disallowedProps)) {\n      throw new Error(['Invalid argument supplied to disallow, expected an instance of array.', \" See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(''));\n    } // skip if prop is undefined\n\n\n    if ((0, _isNil2.default)(props[propName]) || props[propName] === false) return; // find disallowed props with values\n\n    var disallowed = disallowedProps.reduce(function (acc, disallowedProp) {\n      if (!(0, _isNil2.default)(props[disallowedProp]) && props[disallowedProp] !== false) {\n        return (0, _toConsumableArray2.default)(acc).concat([disallowedProp]);\n      }\n\n      return acc;\n    }, []);\n\n    if (disallowed.length > 0) {\n      return new Error([\"Prop `\".concat(propName, \"` in `\").concat(componentName, \"` conflicts with props: `\").concat(disallowed.join('`, `'), \"`.\"), 'They cannot be defined together, choose one or the other.'].join(' '));\n    }\n  };\n};\n/**\n * Ensure a prop adherers to multiple prop type validators.\n * @param {function[]} validators An array of propType functions.\n */\n\n\nexports.disallow = disallow;\n\nvar every = function every(validators) {\n  return function (props, propName, componentName) {\n    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      rest[_key - 3] = arguments[_key];\n    }\n\n    if (!Array.isArray(validators)) {\n      throw new Error(['Invalid argument supplied to every, expected an instance of array.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    }\n\n    var errors = (0, _flow2.default)((0, _map2.default)(function (validator) {\n      if (typeof validator !== 'function') {\n        throw new Error(\"every() argument \\\"validators\\\" should contain functions, found: \".concat(typeOf(validator), \".\"));\n      }\n\n      return validator.apply(void 0, [props, propName, componentName].concat(rest));\n    }), _compact2.default)(validators); // we can only return one error at a time\n\n    return errors[0];\n  };\n};\n/**\n * Ensure a prop adherers to at least one of the given prop type validators.\n * @param {function[]} validators An array of propType functions.\n */\n\n\nexports.every = every;\n\nvar some = function some(validators) {\n  return function (props, propName, componentName) {\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n\n    if (!Array.isArray(validators)) {\n      throw new Error(['Invalid argument supplied to some, expected an instance of array.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    }\n\n    var errors = (0, _compact2.default)((0, _map2.default)(validators, function (validator) {\n      if (!(0, _isFunction2.default)(validator)) {\n        throw new Error(\"some() argument \\\"validators\\\" should contain functions, found: \".concat(typeOf(validator), \".\"));\n      }\n\n      return validator.apply(void 0, [props, propName, componentName].concat(rest));\n    })); // fail only if all validators failed\n\n    if (errors.length === validators.length) {\n      var error = new Error('One of these validators must pass:');\n      error.message += \"\\n\".concat((0, _map2.default)(errors, function (err, i) {\n        return \"[\".concat(i + 1, \"]: \").concat(err.message);\n      }).join('\\n'));\n      return error;\n    }\n  };\n};\n/**\n * Ensure a validator passes only when a component has a given propsShape.\n * @param {object} propsShape An object describing the prop shape.\n * @param {function} validator A propType function.\n */\n\n\nexports.some = some;\n\nvar givenProps = function givenProps(propsShape, validator) {\n  return function (props, propName, componentName) {\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      rest[_key3 - 3] = arguments[_key3];\n    }\n\n    if (!(0, _isPlainObject2.default)(propsShape)) {\n      throw new Error(['Invalid argument supplied to givenProps, expected an object.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    }\n\n    if (typeof validator !== 'function') {\n      throw new Error(['Invalid argument supplied to givenProps, expected a function.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    }\n\n    var shouldValidate = (0, _keys2.default)(propsShape).every(function (key) {\n      var val = propsShape[key]; // require propShape validators to pass or prop values to match\n\n      return typeof val === 'function' ? !val.apply(void 0, [props, key, componentName].concat(rest)) : val === props[propName];\n    });\n    if (!shouldValidate) return;\n    var error = validator.apply(void 0, [props, propName, componentName].concat(rest));\n\n    if (error) {\n      // poor mans shallow pretty print, prevents JSON circular reference errors\n      var prettyProps = \"{ \".concat((0, _keys2.default)((0, _pick2.default)((0, _keys2.default)(propsShape), props)).map(function (key) {\n        var val = props[key];\n        var renderedValue = val;\n        if (typeof val === 'string') renderedValue = \"\\\"\".concat(val, \"\\\"\");else if (Array.isArray(val)) renderedValue = \"[\".concat(val.join(', '), \"]\");else if ((0, _isObject2.default)(val)) renderedValue = '{...}';\n        return \"\".concat(key, \": \").concat(renderedValue);\n      }).join(', '), \" }\");\n      error.message = \"Given props \".concat(prettyProps, \": \").concat(error.message);\n      return error;\n    }\n  };\n};\n/**\n * Define prop dependencies by requiring other props.\n * @param {string[]} requiredProps An array of required prop names.\n */\n\n\nexports.givenProps = givenProps;\n\nvar demand = function demand(requiredProps) {\n  return function (props, propName, componentName) {\n    if (!Array.isArray(requiredProps)) {\n      throw new Error(['Invalid `requiredProps` argument supplied to require, expected an instance of array.', \" See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(''));\n    } // skip if prop is undefined\n\n\n    if (props[propName] === undefined) return;\n    var missingRequired = requiredProps.filter(function (requiredProp) {\n      return props[requiredProp] === undefined;\n    });\n\n    if (missingRequired.length > 0) {\n      return new Error(\"`\".concat(propName, \"` prop in `\").concat(componentName, \"` requires props: `\").concat(missingRequired.join('`, `'), \"`.\"));\n    }\n  };\n};\n/**\n * Ensure an multiple prop contains a string with only possible values.\n * @param {string[]} possible An array of possible values to prop.\n */\n\n\nexports.demand = demand;\n\nvar multipleProp = function multipleProp(possible) {\n  return function (props, propName, componentName) {\n    if (!Array.isArray(possible)) {\n      throw new Error(['Invalid argument supplied to some, expected an instance of array.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    }\n\n    var propValue = props[propName]; // skip if prop is undefined\n\n    if ((0, _isNil2.default)(propValue) || propValue === false) return;\n    var values = propValue.replace('large screen', 'large-screen').replace(/ vertically/g, '-vertically').split(' ').map(function (val) {\n      return (0, _trim2.default)(val).replace('-', ' ');\n    });\n    var invalid = (0, _difference2.default)(values, possible); // fail only if there are invalid values\n\n    if (invalid.length > 0) {\n      return new Error(\"`\".concat(propName, \"` prop in `\").concat(componentName, \"` has invalid values: `\").concat(invalid.join('`, `'), \"`.\"));\n    }\n  };\n};\n/**\n * Ensure a component can render as a node passed as a prop value in place of children.\n */\n\n\nexports.multipleProp = multipleProp;\n\nvar contentShorthand = function contentShorthand() {\n  return every([disallow(['children']), _propTypes.default.node]).apply(void 0, arguments);\n};\n/**\n * Item shorthand is a description of a component that can be a literal,\n * a props object, or an element.\n */\n\n\nexports.contentShorthand = contentShorthand;\n\nvar itemShorthand = function itemShorthand() {\n  return every([disallow(['children']), _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.node, _propTypes.default.object, _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.object]))])]).apply(void 0, arguments);\n};\n/**\n * Collection shorthand ensures a prop is an array of item shorthand.\n */\n\n\nexports.itemShorthand = itemShorthand;\n\nvar collectionShorthand = function collectionShorthand() {\n  return every([disallow(['children']), _propTypes.default.arrayOf(itemShorthand)]).apply(void 0, arguments);\n};\n/**\n * Show a deprecated warning for component props with a help message and optional validator.\n * @param {string} help A help message to display with the deprecation warning.\n * @param {function} [validator] A propType function.\n */\n\n\nexports.collectionShorthand = collectionShorthand;\n\nvar deprecate = function deprecate(help, validator) {\n  return function (props, propName, componentName) {\n    if (typeof help !== 'string') {\n      throw new Error(['Invalid `help` argument supplied to deprecate, expected a string.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n    } // skip if prop is undefined\n\n\n    if (props[propName] === undefined) return; // deprecation error and help\n\n    var error = new Error(\"The `\".concat(propName, \"` prop in `\").concat(componentName, \"` is deprecated.\"));\n    if (help) error.message += \" \".concat(help); // add optional validation error message\n\n    if (validator) {\n      if (typeof validator === 'function') {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n          args[_key4 - 3] = arguments[_key4];\n        }\n\n        var validationError = validator.apply(void 0, [props, propName, componentName].concat(args));\n\n        if (validationError) {\n          error.message = \"\".concat(error.message, \" \").concat(validationError.message);\n        }\n      } else {\n        throw new Error(['Invalid argument supplied to deprecate, expected a function.', \"See `\".concat(propName, \"` prop in `\").concat(componentName, \"`.\")].join(' '));\n      }\n    }\n\n    return error;\n  };\n};\n\nexports.deprecate = deprecate;","map":null,"metadata":{},"sourceType":"script"}